DROP FUNCTION IF EXISTS func_data_structure;CREATE OR REPLACE FUNCTION func_data_structure(	INOUT tables_name VARCHAR(100),	OUT field_comment VARCHAR(200),	OUT field_type VARCHAR(200),	OUT field_name VARCHAR(200),	OUT field_primary BOOLEAN,	OUT field_is_notnull BOOLEAN,	OUT field_is_enum BOOLEAN,	OUT field_options JSON) RETURNS SETOF RECORDAS $$DECLARE	pk_array VARCHAR[];	rec RECORD;BEGIN	SELECT array_agg(table_pk_name) INTO pk_array FROM func_table_primary('base_user_realname');	FOR rec IN (SELECT col_description(pg_attribute.attrelid, pg_attribute.attnum) AS title,	                   pg_type.typname AS datetype,	                   pg_attribute.attname AS field,	                   pg_attribute.attnotnull AS is_notnull,	                   (CASE WHEN (pg_type.typcategory = 'E') THEN TRUE ELSE FALSE END) AS is_enum,	                   (CASE WHEN (pg_type.typcategory = 'E') THEN			                   (SELECT json_agg(enumlabel) FROM pg_enum WHERE enumtypid = (pg_type.typarray::INTEGER + 1))	                         ELSE NULL END) AS option_list	            FROM pg_class, pg_attribute INNER JOIN pg_type ON pg_type.oid = pg_attribute.atttypid	            WHERE pg_class.relname = tables_name			          AND pg_attribute.attrelid = pg_class.oid			          AND pg_attribute.attnum > 0) LOOP		field_comment := rec.title;		field_type := rec.datetype;		field_name := rec.field;		field_primary := pk_array @> ARRAY[rec.field::VARCHAR];		field_is_notnull := rec.is_notnull;		field_is_enum := rec.is_enum;		field_options := rec.option_list;		RETURN NEXT;	END LOOP;END;$$ LANGUAGE plpgsql;COMMENT ON FUNCTION func_data_structure(VARCHAR) IS '获取指定表或视图的数据结构';DROP FUNCTION IF EXISTS func_table_primary;CREATE OR REPLACE FUNCTION func_table_primary(	INOUT tables_name VARCHAR(100),	OUT table_pk_name VARCHAR(100),	OUT table_pk_comment VARCHAR(200),	OUT table_pk_datetype VARCHAR(200)) RETURNS SETOF RECORDAS $$DECLARE	rec RECORD;BEGIN	FOR rec IN (SELECT pg_attribute.attname AS pk_name,	                   col_description(pg_attribute.attrelid, pg_attribute.attnum) AS title,	                   pg_type.typname AS datetype	            FROM pg_constraint INNER JOIN pg_class ON pg_constraint.conrelid = pg_class.oid	                               INNER JOIN pg_attribute ON pg_attribute.attrelid = pg_class.oid		                                                          AND pg_attribute.attnum = pg_constraint.conkey[1]	                               INNER JOIN pg_type ON pg_type.oid = pg_attribute.atttypid	            WHERE pg_class.relname = tables_name AND pg_constraint.contype = 'p') LOOP		table_pk_name := rec.pk_name;		table_pk_comment := rec.title;		table_pk_datetype := rec.datetype;		RETURN NEXT;	END LOOP;END;$$ LANGUAGE plpgsql;COMMENT ON FUNCTION func_table_primary(VARCHAR) IS '获取指定表的主键';DROP FUNCTION IF EXISTS func_table_optgroup;CREATE OR REPLACE FUNCTION func_table_optgroup(	IN prex VARCHAR(50))RETURNS JSONAS $$DECLARE	option_val JSON;BEGIN	SELECT json_agg(row_to_json(option_data)) INTO option_val	FROM (SELECT pc.relname as value,	             obj_description(pc.oid) as label,	             (CASE WHEN pc.relkind = 'r' THEN '数据表'	                   WHEN pc.relkind = 'v' THEN '视图'	                   ELSE '外部表' END)AS optgroup	      FROM pg_class pc WHERE pc.relname LIKE prex || '_%' AND pc.relkind IN ('r', 'v', 'f')) AS option_data;	RETURN option_val;END;$$ LANGUAGE plpgsql;COMMENT ON FUNCTION func_table_optgroup(VARCHAR) IS '获取指定前缀的表、视图、外部表的OPTION数据';DROP FUNCTION IF EXISTS func_proname_optgroup;CREATE OR REPLACE FUNCTION func_proname_optgroup()RETURNS JSONAS $$DECLARE	option_val JSON;BEGIN	SELECT json_agg(row_to_json(option_data)) INTO option_val	FROM (SELECT p.proname AS value,	       obj_description(p.oid) as label,	       (CASE WHEN p.proname LIKE 'func_%' THEN '自定义函数' ELSE '存储过程' END) AS optgroup	FROM pg_proc p WHERE proname LIKE 'func_%' OR proname LIKE 'logic_%') AS option_data;	RETURN option_val;END;$$ LANGUAGE plpgsql;COMMENT ON FUNCTION func_proname_optgroup() IS '获取自定义函数、存储过程的OPTION数据';